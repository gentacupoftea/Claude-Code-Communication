# 長時間実行プロセスの自動再起動ベストプラクティス

## 1. 背景
サーバーで長時間実行されるプロセス（デーモン、監視スクリプト等）は、メモリリークやステートの肥大化により、時間経過とともにパフォーマンスが劣化したり、リソースを過剰に消費したりする問題が発生することがある。
本ドキュメントは、定期的な自動再起動によって、これらの問題を予防的に解決するためのベストプラクティスを記述する。

## 2. 解決策
解決策は、プロセスの再起動を自動化するスクリプトと、それを定期的に実行するスケジューラ（Cronなど）の組み合わせで構成される。

### 2.1. 自動再起動スクリプト
**目的**: 対象のプロセスを安全に停止し、クリーンな状態で再起動する。

#### 主な機能
- **安全な停止**: 既存プロセスに `SIGTERM` を送信し、グレースフルシャットダウンを試みる。一定時間後に終了しない場合は `SIGKILL` で強制終了する。
- **ステートクリーンアップ**: 再起動前に、古い一時ファイルやステートファイルを削除する。
- **ログ記録**: いつ、どのプロセスが再起動されたか、といった操作をログファイルに記録する。
- **起動検証**: 新しいプロセスが正常に起動したことを確認する。

#### 実装例 (`bash`)
```bash
#!/bin/bash

SUPERVISOR_SCRIPT="/path/to/your/script.sh"
PID_FILE="/var/run/supervisor.pid"
LOG_FILE="/var/log/supervisor-restart.log"

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 既存プロセスのPIDを取得
if [ ! -f $PID_FILE ]; then
    log "PID file not found. Starting new process."
    nohup $SUPERVISOR_SCRIPT & echo $! > $PID_FILE
    exit 0
fi

OLD_PID=$(cat $PID_FILE)

# プロセスを安全に停止
log "Stopping process with PID: $OLD_PID"
kill -TERM $OLD_PID
sleep 5

if ps -p $OLD_PID > /dev/null; then
    log "Process did not stop gracefully. Sending SIGKILL."
    kill -KILL $OLD_PID
fi

# ステートファイルのクリーンアップ
# find /tmp/supervisor_state/ -type f -mmin +60 -delete

# 新しいプロセスを起動
log "Starting new process."
nohup $SUPERVISOR_SCRIPT & echo $! > $PID_FILE

log "Restart complete. New PID: $(cat $PID_FILE)"
```

### 2.2. 定期実行 (Cron)
システムの負荷が低い時間帯（例: 毎日午前3時）に、再起動スクリプトを実行するようスケジュールする。

```cron
# 毎日午前3時にsupervisor-restart.shを実行
0 3 * * * /path/to/supervisor-restart.sh
```

### 2.3. ログ管理
再起動の履歴やエラーを追跡できるよう、ログを適切に管理する。
- **ログローテーション**: ログファイルが肥大化しないように、`logrotate`などを設定する。
- **ログ内容**: 再起動日時、旧/新プロセスID、メモリ使用量（任意）、エラー情報などを記録する。

## 3. 期待される効果
- **メモリリーク防止**: 定期的なリセットにより、メモリ使用量の累積を防ぐ。
- **安定性の向上**: 長時間実行に起因する潜在的な問題を未然に回避する。
- **運用の自動化**: 手動でのプロセス再起動が不要になり、運用コストが削減される。
- **予防的保守**: 問題が表面化する前に対処できる。

## 4. 運用ガイドライン

### 4.1. 導入手順
1. 再起動スクリプトを作成し、サーバーに配置する。
2. スクリプトに実行権限を付与する (`chmod +x supervisor-restart.sh`)。
3. `crontab` を設定し、定期実行をスケジュールする。
4. ログディレクトリやPIDファイルを保存するディレクトリを作成し、適切な権限を設定する。

### 4.2. 監視項目
- 定期的にログファイルを確認し、再起動が正常に行われているか監視する。
- 再起動前後のメモリやCPU使用量を監視し、実際にリソースが解放されているか確認する。
- エラーログが出力されていないか監視する。

### 4.3. トラブルシューティング
- **問題発生時**: まずログファイルを確認する。
- **手動テスト**: スクリプトを直接実行して、意図通りに動作するかテストする。
- **Cron設定**: `crontab -l` で設定内容を確認する。

## 5. 応用
このベストプラクティスは、長時間実行されるあらゆる種類のバックグラウンドプロセスに適用可能である。
- バックグラウンドワーカー
- 監視デーモン
- データ収集・集計プロセス

### 拡張アイデア
- **メトリクス連携**: Prometheusなどの監視ツールと連携し、再起動イベントやリソース使用状況をダッシュボードで可視化する。
- **アラート機能**: 再起動に失敗した場合などに、Slackやメールで管理者に通知する。
- **動的スケジューリング**: システムの負荷状況に応じて、再起動のタイミングを動的に調整する。