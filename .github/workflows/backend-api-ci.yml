name: Backend API CI/CD

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-api-ci.yml'
  # PRæ™‚ã¯è»½é‡ãªpr-checks.ymlãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€ãƒ•ãƒ«å®Ÿè¡Œã¯çœç•¥

env:
  NODE_VERSION: '18'
  WORKING_DIRECTORY: 'backend'
  REGISTRY: asia-northeast1-docker.pkg.dev
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  SERVICE_NAME: conea-backend-api
  REGION: asia-northeast1

jobs:
  test:
    name: Build and Test Backend API
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIRECTORY }}
    
    services:
      redis:
        image: redis:alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: ${{ env.WORKING_DIRECTORY }}/package-lock.json
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linting (if available)
        run: |
          if npm run --silent lint 2>/dev/null; then
            npm run lint
          else
            echo "No lint script found, skipping linting"
          fi
        # ãƒªãƒ³ãƒ†ã‚£ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ã¯ã‚³ãƒ¼ãƒ‰å“è³ªã«å½±éŸ¿ã™ã‚‹ãŸã‚å¤±æ•—æ™‚ã¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’åœæ­¢
      
      - name: Run unit tests
        run: npm run test:unit
        env:
          NODE_ENV: test
          REDIS_URL: redis://localhost:6379
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          NODE_ENV: test
          REDIS_URL: redis://localhost:6379
        # ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã®å¤±æ•—ã¯é‡è¦ãªå•é¡Œã¨ã—ã¦æ‰±ã†
      
      - name: Run test coverage
        run: npm run test:coverage
        env:
          NODE_ENV: test
          REDIS_URL: redis://localhost:6379
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        with:
          file: ${{ env.WORKING_DIRECTORY }}/coverage/lcov.info
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true
        # ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—ã¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åœæ­¢ã®å¿…è¦ãªã—
      
      - name: Run security audit
        run: npm audit --audit-level=moderate
        # ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºæº–ï¼šmoderateä»¥ä¸Šã®è„†å¼±æ€§ã§ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åœæ­¢

  build:
    name: Build Docker Image
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    outputs:
      image: ${{ steps.build.outputs.image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Configure Docker for Google Cloud
        run: gcloud auth configure-docker ${{ env.REGISTRY }}
      
      - name: Build Docker image
        id: build
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}"
          IMAGE_TAG="${GITHUB_SHA::8}"
          FULL_IMAGE="${IMAGE_NAME}:${IMAGE_TAG}"
          
          # Dockerfileãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹é©ç”¨ç¢ºèª:
          # - ãƒãƒ«ãƒã‚¹ãƒ†ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰åˆ©ç”¨
          # - .dockerignoreã«ã‚ˆã‚‹ä¸è¦ãƒ•ã‚¡ã‚¤ãƒ«é™¤å¤–
          # - è„†å¼±æ€§ã®ãªã„ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ¡ãƒ¼ã‚¸é¸æŠ
          # - érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã®å®Ÿè¡Œ
          
          docker build -t $FULL_IMAGE ${{ env.WORKING_DIRECTORY }}
          docker push $FULL_IMAGE
          
          echo "image=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "Built and pushed: $FULL_IMAGE"

  deploy-staging:
    name: Deploy to Cloud Run (Staging)
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: staging
    
    steps:
      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Deploy to Cloud Run (Staging)
        run: |
          gcloud run deploy ${{ env.SERVICE_NAME }}-staging \
            --image=${{ needs.build.outputs.image }} \
            --platform=managed \
            --region=${{ env.REGION }} \
            --allow-unauthenticated \
            --set-env-vars="NODE_ENV=staging" \
            --set-env-vars="REDIS_URL=${{ secrets.STAGING_REDIS_URL }}" \
            --set-env-vars="DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}" \
            --memory=1Gi \
            --cpu=1 \
            --min-instances=0 \
            --max-instances=10 \
            --timeout=300s \
            --port=8000
      
      - name: Get service URL
        id: deploy
        run: |
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }}-staging \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service deployed at: $SERVICE_URL"
      
      - name: Run post-deployment health check
        run: |
          sleep 30
          curl -f ${{ steps.deploy.outputs.service_url }}/api/health || exit 1
          echo "âœ… Health check passed"
      
      - name: Update staging secrets (if needed)
        run: |
          echo "SERVICE_URL=${{ steps.deploy.outputs.service_url }}" >> $GITHUB_ENV

  deploy-production:
    name: Deploy to Cloud Run (Production)
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    
    steps:
      - name: Setup Google Cloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}
      
      - name: Deploy to Cloud Run (Production)
        run: |
          gcloud run deploy ${{ env.SERVICE_NAME }}-production \
            --image=${{ needs.build.outputs.image }} \
            --platform=managed \
            --region=${{ env.REGION }} \
            --allow-unauthenticated \
            --set-env-vars="NODE_ENV=production" \
            --set-env-vars="REDIS_URL=${{ secrets.PRODUCTION_REDIS_URL }}" \
            --set-env-vars="DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}" \
            --memory=2Gi \
            --cpu=2 \
            --min-instances=1 \
            --max-instances=50 \
            --timeout=300s \
            --port=8000 \
            --cpu-throttling \
            --execution-environment=gen2
      
      - name: Get service URL
        id: deploy
        run: |
          SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }}-production \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Service deployed at: $SERVICE_URL"
      
      - name: Run comprehensive health check
        run: |
          sleep 60
          
          # Health check
          curl -f ${{ steps.deploy.outputs.service_url }}/api/health || exit 1
          echo "âœ… Health check passed"
          
          # API endpoint check
          curl -f ${{ steps.deploy.outputs.service_url }}/api/status || exit 1
          echo "âœ… API status check passed"
      
      - name: Notify deployment success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              attachments: [{
                color: 'good',
                text: `âœ… Backend API deployed successfully to production\nğŸ”— Service URL: ${{ steps.deploy.outputs.service_url }}\nğŸ“¦ Image: ${{ needs.build.outputs.image }}\nğŸ‘¤ Author: ${{ github.actor }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify deployment failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              attachments: [{
                color: 'danger',
                text: `âŒ Backend API deployment to production failed\nğŸ“¦ Image: ${{ needs.build.outputs.image }}\nğŸ‘¤ Author: ${{ github.actor }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIRECTORY }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner on Dockerfile
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '${{ env.WORKING_DIRECTORY }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
        # CRITICALãƒ»HIGHãƒ¬ãƒ™ãƒ«ã®è„†å¼±æ€§æ¤œå‡ºæ™‚ã¯ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åœæ­¢
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true
        if: always()
        # çµæœã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¯å¸¸ã«å®Ÿè¡Œï¼ˆã‚¹ã‚­ãƒ£ãƒ³å¤±æ•—æ™‚ã‚‚å«ã‚€ï¼‰