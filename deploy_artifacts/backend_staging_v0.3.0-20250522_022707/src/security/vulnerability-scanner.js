/**
 * Vulnerability Scanner for Shopify MCP Server
 * 
 * OWASP Top 10に基づく自動脆弱性検出システム
 */

const axios = require('axios');
const { URL } = require('url');
const crypto = require('crypto');
const dns = require('dns').promises;
const net = require('net');
const tls = require('tls');
const winston = require('winston');

// 脆弱性スキャナー用のロガー
const scannerLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'vulnerability-scan.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

/**
 * 包括的な脆弱性スキャナー
 */
class VulnerabilityScanner {
  constructor(config = {}) {
    this.config = {
      targetUrl: config.targetUrl,
      scanTimeout: config.scanTimeout || 30000,
      maxConcurrentScans: config.maxConcurrentScans || 5,
      userAgent: config.userAgent || 'Shopify-MCP-Security-Scanner/1.0',
      
      // スキャン設定
      enabledScans: {
        injection: config.enabledScans?.injection !== false,
        brokenAuth: config.enabledScans?.brokenAuth !== false,
        sensitiveData: config.enabledScans?.sensitiveData !== false,
        xxe: config.enabledScans?.xxe !== false,
        brokenAccessControl: config.enabledScans?.brokenAccessControl !== false,
        securityMisconfig: config.enabledScans?.securityMisconfig !== false,
        xss: config.enabledScans?.xss !== false,
        insecureDeserialization: config.enabledScans?.insecureDeserialization !== false,
        knownVulnerabilities: config.enabledScans?.knownVulnerabilities !== false,
        logging: config.enabledScans?.logging !== false
      }
    };
    
    this.results = [];
    this.startTime = null;
    this.endTime = null;
  }
  
  /**
   * 完全スキャンの実行
   */
  async runFullScan() {
    this.startTime = Date.now();
    this.results = [];
    
    scannerLogger.info('Starting vulnerability scan', {
      targetUrl: this.config.targetUrl,
      enabledScans: this.config.enabledScans
    });
    
    const scanPromises = [];
    
    // A1: Injection
    if (this.config.enabledScans.injection) {
      scanPromises.push(this.scanInjectionVulnerabilities());
    }
    
    // A2: Broken Authentication
    if (this.config.enabledScans.brokenAuth) {
      scanPromises.push(this.scanBrokenAuthentication());
    }
    
    // A3: Sensitive Data Exposure
    if (this.config.enabledScans.sensitiveData) {
      scanPromises.push(this.scanSensitiveDataExposure());
    }
    
    // A4: XML External Entities (XXE)
    if (this.config.enabledScans.xxe) {
      scanPromises.push(this.scanXXEVulnerabilities());
    }
    
    // A5: Broken Access Control
    if (this.config.enabledScans.brokenAccessControl) {
      scanPromises.push(this.scanBrokenAccessControl());
    }
    
    // A6: Security Misconfiguration
    if (this.config.enabledScans.securityMisconfig) {
      scanPromises.push(this.scanSecurityMisconfiguration());
    }
    
    // A7: Cross-Site Scripting (XSS)
    if (this.config.enabledScans.xss) {
      scanPromises.push(this.scanXSSVulnerabilities());
    }
    
    // A8: Insecure Deserialization
    if (this.config.enabledScans.insecureDeserialization) {
      scanPromises.push(this.scanInsecureDeserialization());
    }
    
    // A9: Using Components with Known Vulnerabilities
    if (this.config.enabledScans.knownVulnerabilities) {
      scanPromises.push(this.scanKnownVulnerabilities());
    }
    
    // A10: Insufficient Logging & Monitoring
    if (this.config.enabledScans.logging) {
      scanPromises.push(this.scanLoggingAndMonitoring());
    }
    
    // すべてのスキャンを並行実行
    await Promise.allSettled(scanPromises);
    
    this.endTime = Date.now();
    
    return this.generateReport();
  }
  
  /**
   * A1: Injection攻撃のスキャン
   */
  async scanInjectionVulnerabilities() {
    const category = 'Injection';
    scannerLogger.info(`Scanning for ${category} vulnerabilities`);
    
    const injectionPayloads = [
      // SQL Injection
      { type: 'sql', payload: "' OR '1'='1" },
      { type: 'sql', payload: "1; DROP TABLE users--" },
      { type: 'sql', payload: "' UNION SELECT * FROM information_schema.tables--" },
      
      // NoSQL Injection
      { type: 'nosql', payload: '{"$ne": null}' },
      { type: 'nosql', payload: '{"$gt": ""}' },
      
      // Command Injection
      { type: 'cmd', payload: '; ls -la' },
      { type: 'cmd', payload: '| whoami' },
      { type: 'cmd', payload: '`id`' },
      
      // LDAP Injection
      { type: 'ldap', payload: '*)(|(objectClass=*' },
      { type: 'ldap', payload: 'admin)(&(|' }
    ];
    
    for (const { type, payload } of injectionPayloads) {
      try {
        const testUrl = new URL(this.config.targetUrl);
        testUrl.searchParams.set('q', payload);
        
        const response = await this.makeRequest(testUrl.toString());
        
        // エラーメッセージのチェック
        const errorPatterns = [
          /SQL syntax.*MySQL/i,
          /Warning.*mysql_/i,
          /ORA-[0-9]{5}/,
          /PostgreSQL.*ERROR/i,
          /Microsoft.*ODBC.*SQL/i,
          /SQLite.*error/i,
          /mongodb error/i,
          /LDAP.*error/i
        ];
        
        for (const pattern of errorPatterns) {
          if (pattern.test(response.data)) {
            this.addVulnerability({
              category,
              severity: 'critical',
              type: `${type}_injection`,
              description: `Possible ${type} injection vulnerability detected`,
              payload,
              evidence: response.data.match(pattern)[0],
              recommendation: 'Use parameterized queries and input validation'
            });
            break;
          }
        }
        
        // 実行時間の異常をチェック（Time-based injection）
        if (response.duration > 5000) {
          this.addVulnerability({
            category,
            severity: 'high',
            type: `${type}_injection_time_based`,
            description: `Possible time-based ${type} injection`,
            payload,
            evidence: `Response time: ${response.duration}ms`,
            recommendation: 'Implement query timeouts and input sanitization'
          });
        }
      } catch (error) {
        scannerLogger.error(`Error scanning ${type} injection:`, error.message);
      }
    }
  }
  
  /**
   * A2: 認証の不備をスキャン
   */
  async scanBrokenAuthentication() {
    const category = 'Broken Authentication';
    scannerLogger.info(`Scanning for ${category} vulnerabilities`);
    
    const tests = [
      // 弱いパスワードのテスト
      {
        name: 'weak_passwords',
        credentials: [
          { username: 'admin', password: 'admin' },
          { username: 'admin', password: 'password' },
          { username: 'admin', password: '123456' },
          { username: 'test', password: 'test' },
          { username: 'demo', password: 'demo' }
        ]
      },
      
      // セッション管理のテスト
      {
        name: 'session_management',
        tests: [
          'session_fixation',
          'session_timeout',
          'concurrent_sessions'
        ]
      },
      
      // ブルートフォース保護のテスト
      {
        name: 'brute_force_protection',
        attempts: 10
      }
    ];
    
    // 弱いパスワードのテスト
    for (const { username, password } of tests[0].credentials) {
      try {
        const response = await this.makeRequest(`${this.config.targetUrl}/api/login`, {
          method: 'POST',
          data: { username, password }
        });
        
        if (response.status === 200) {
          this.addVulnerability({
            category,
            severity: 'critical',
            type: 'weak_credentials',
            description: 'Default or weak credentials accepted',
            evidence: `Login successful with ${username}:${password}`,
            recommendation: 'Enforce strong password policies and remove default credentials'
          });
        }
      } catch (error) {
        // エラーは想定内
      }
    }
    
    // ブルートフォース保護のテスト
    let blockedAfter = null;
    for (let i = 0; i < tests[2].attempts; i++) {
      try {
        await this.makeRequest(`${this.config.targetUrl}/api/login`, {
          method: 'POST',
          data: {
            username: 'testuser',
            password: `wrongpassword${i}`
          }
        });
      } catch (error) {
        if (error.response?.status === 429) {
          blockedAfter = i + 1;
          break;
        }
      }
    }
    
    if (!blockedAfter || blockedAfter > 5) {
      this.addVulnerability({
        category,
        severity: 'high',
        type: 'no_brute_force_protection',
        description: 'Insufficient brute force protection',
        evidence: blockedAfter ? `Blocked after ${blockedAfter} attempts` : 'No blocking detected',
        recommendation: 'Implement rate limiting and account lockout mechanisms'
      });
    }
  }
  
  /**
   * A3: 機密データ露出のスキャン
   */
  async scanSensitiveDataExposure() {
    const category = 'Sensitive Data Exposure';
    scannerLogger.info(`Scanning for ${category} vulnerabilities`);
    
    // HTTPSのチェック
    const url = new URL(this.config.targetUrl);
    if (url.protocol === 'http:') {
      this.addVulnerability({
        category,
        severity: 'high',
        type: 'no_https',
        description: 'Service not using HTTPS',
        evidence: 'HTTP protocol detected',
        recommendation: 'Enable HTTPS with a valid SSL certificate'
      });
    }
    
    // SSL/TLS設定のチェック
    if (url.protocol === 'https:') {
      try {
        const tlsInfo = await this.checkTLSConfiguration(url.hostname);
        
        // 弱い暗号スイートのチェック
        if (tlsInfo.cipherName && tlsInfo.cipherName.includes('RC4')) {
          this.addVulnerability({
            category,
            severity: 'medium',
            type: 'weak_cipher',
            description: 'Weak cipher suite in use',
            evidence: `Cipher: ${tlsInfo.cipherName}`,
            recommendation: 'Disable weak ciphers and use modern TLS configuration'
          });
        }
        
        // 古いTLSバージョンのチェック
        if (tlsInfo.protocol && (tlsInfo.protocol === 'TLSv1' || tlsInfo.protocol === 'TLSv1.1')) {
          this.addVulnerability({
            category,
            severity: 'medium',
            type: 'outdated_tls',
            description: 'Outdated TLS version',
            evidence: `Protocol: ${tlsInfo.protocol}`,
            recommendation: 'Use TLS 1.2 or higher'
          });
        }
      } catch (error) {
        scannerLogger.error('Error checking TLS configuration:', error.message);
      }
    }
    
    // レスポンスヘッダーのチェック
    try {
      const response = await this.makeRequest(this.config.targetUrl);
      
      // 機密情報を含む可能性のあるヘッダー
      const sensitiveHeaders = ['X-Powered-By', 'Server', 'X-AspNet-Version'];
      for (const header of sensitiveHeaders) {
        if (response.headers[header.toLowerCase()]) {
          this.addVulnerability({
            category,
            severity: 'low',
            type: 'information_disclosure',
            description: `Sensitive header exposed: ${header}`,
            evidence: `${header}: ${response.headers[header.toLowerCase()]}`,
            recommendation: 'Remove or obfuscate server information headers'
          });
        }
      }
      
      // エラーページでの情報漏洩チェック
      const errorResponse = await this.makeRequest(`${this.config.targetUrl}/nonexistent`, {
        validateStatus: () => true
      });
      
      const errorPatterns = [
        /stack trace/i,
        /at\s+\w+\s+\(/,
        /\.java:\d+/,
        /\.cs:\d+/,
        /\.php on line \d+/,
        /Traceback \(most recent call last\)/
      ];
      
      for (const pattern of errorPatterns) {
        if (pattern.test(errorResponse.data)) {
          this.addVulnerability({
            category,
            severity: 'medium',
            type: 'detailed_error_messages',
            description: 'Detailed error messages exposed',
            evidence: 'Stack trace or detailed error information found',
            recommendation: 'Implement custom error pages without sensitive information'
          });
          break;
        }
      }
    } catch (error) {
      scannerLogger.error('Error checking response headers:', error.message);
    }
  }
  
  /**
   * A6: セキュリティ設定ミスのスキャン
   */
  async scanSecurityMisconfiguration() {
    const category = 'Security Misconfiguration';
    scannerLogger.info(`Scanning for ${category} vulnerabilities`);
    
    // セキュリティヘッダーのチェック
    try {
      const response = await this.makeRequest(this.config.targetUrl);
      const headers = response.headers;
      
      const requiredHeaders = {
        'strict-transport-security': {
          severity: 'medium',
          description: 'Missing HSTS header'
        },
        'x-content-type-options': {
          severity: 'medium',
          description: 'Missing X-Content-Type-Options header'
        },
        'x-frame-options': {
          severity: 'medium',
          description: 'Missing X-Frame-Options header'
        },
        'x-xss-protection': {
          severity: 'low',
          description: 'Missing X-XSS-Protection header'
        },
        'content-security-policy': {
          severity: 'medium',
          description: 'Missing Content-Security-Policy header'
        }
      };
      
      for (const [header, config] of Object.entries(requiredHeaders)) {
        if (!headers[header]) {
          this.addVulnerability({
            category,
            severity: config.severity,
            type: 'missing_security_header',
            description: config.description,
            evidence: `Header not found: ${header}`,
            recommendation: `Add ${header} header with appropriate value`
          });
        }
      }
      
      // デフォルトページのチェック
      const defaultPaths = [
        '/admin',
        '/manager',
        '/phpmyadmin',
        '/.git',
        '/.env',
        '/config.php',
        '/wp-admin',
        '/server-status'
      ];
      
      for (const path of defaultPaths) {
        try {
          const response = await this.makeRequest(`${this.config.targetUrl}${path}`, {
            validateStatus: (status) => status < 500
          });
          
          if (response.status === 200) {
            this.addVulnerability({
              category,
              severity: 'high',
              type: 'exposed_admin_interface',
              description: `Exposed administrative interface: ${path}`,
              evidence: `HTTP ${response.status} response`,
              recommendation: 'Remove or properly secure administrative interfaces'
            });
          }
        } catch (error) {
          // エラーは想定内
        }
      }
      
      // CORSの設定チェック
      if (headers['access-control-allow-origin'] === '*') {
        this.addVulnerability({
          category,
          severity: 'medium',
          type: 'misconfigured_cors',
          description: 'CORS allows all origins',
          evidence: 'Access-Control-Allow-Origin: *',
          recommendation: 'Configure CORS to allow only trusted domains'
        });
      }
    } catch (error) {
      scannerLogger.error('Error scanning security misconfiguration:', error.message);
    }
  }
  
  /**
   * A7: XSS脆弱性のスキャン
   */
  async scanXSSVulnerabilities() {
    const category = 'Cross-Site Scripting';
    scannerLogger.info(`Scanning for ${category} vulnerabilities`);
    
    const xssPayloads = [
      // 基本的なXSSペイロード
      '<script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      'javascript:alert("XSS")',
      '<svg onload=alert("XSS")>',
      
      // エンコードされたペイロード
      '&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;',
      '&#60;script&#62;alert(&#34;XSS&#34;)&#60;/script&#62;',
      
      // イベントハンドラーベース
      '" onmouseover="alert(\'XSS\')" "',
      '\' onmouseover=\'alert("XSS")\' \'',
      
      // 属性ベース
      '"><script>alert("XSS")</script>',
      '\'/><script>alert("XSS")</script>'
    ];
    
    // 各ペイロードをテスト
    for (const payload of xssPayloads) {
      try {
        // GETパラメータでのテスト
        const getUrl = new URL(this.config.targetUrl);
        getUrl.searchParams.set('q', payload);
        
        const getResponse = await this.makeRequest(getUrl.toString());
        
        if (getResponse.data.includes(payload)) {
          this.addVulnerability({
            category,
            severity: 'high',
            type: 'reflected_xss',
            description: 'Reflected XSS vulnerability in GET parameter',
            payload,
            evidence: 'Payload reflected in response without encoding',
            recommendation: 'Encode all user input before output'
          });
        }
        
        // POSTパラメータでのテスト
        const postResponse = await this.makeRequest(this.config.targetUrl, {
          method: 'POST',
          data: { comment: payload }
        });
        
        if (postResponse.data.includes(payload)) {
          this.addVulnerability({
            category,
            severity: 'high',
            type: 'reflected_xss',
            description: 'Reflected XSS vulnerability in POST parameter',
            payload,
            evidence: 'Payload reflected in response without encoding',
            recommendation: 'Encode all user input before output'
          });
        }
      } catch (error) {
        // エラーは想定内
      }
    }
    
    // DOMベースXSSのチェック
    try {
      const response = await this.makeRequest(this.config.targetUrl);
      
      // 危険なJavaScriptパターンの検出
      const dangerousPatterns = [
        /document\.write\([^)]*\)/g,
        /innerHTML\s*=\s*[^;]+/g,
        /eval\([^)]*\)/g,
        /location\.href\s*=\s*[^;]+/g
      ];
      
      for (const pattern of dangerousPatterns) {
        if (pattern.test(response.data)) {
          this.addVulnerability({
            category,
            severity: 'medium',
            type: 'potential_dom_xss',
            description: 'Potentially dangerous JavaScript pattern detected',
            evidence: response.data.match(pattern)[0],
            recommendation: 'Review JavaScript code for DOM-based XSS vulnerabilities'
          });
        }
      }
    } catch (error) {
      scannerLogger.error('Error checking for DOM XSS:', error.message);
    }
  }
  
  /**
   * ユーティリティ: HTTPリクエストの実行
   */
  async makeRequest(url, options = {}) {
    const startTime = Date.now();
    
    try {
      const response = await axios({
        url,
        timeout: this.config.scanTimeout,
        headers: {
          'User-Agent': this.config.userAgent,
          ...options.headers
        },
        ...options
      });
      
      return {
        status: response.status,
        headers: response.headers,
        data: typeof response.data === 'string' ? response.data : JSON.stringify(response.data),
        duration: Date.now() - startTime
      };
    } catch (error) {
      if (error.response) {
        return {
          status: error.response.status,
          headers: error.response.headers,
          data: typeof error.response.data === 'string' ? error.response.data : JSON.stringify(error.response.data),
          duration: Date.now() - startTime,
          error: true
        };
      }
      throw error;
    }
  }
  
  /**
   * TLS設定のチェック
   */
  async checkTLSConfiguration(hostname) {
    return new Promise((resolve, reject) => {
      const socket = tls.connect(443, hostname, {
        rejectUnauthorized: false
      }, () => {
        const cert = socket.getPeerCertificate();
        const cipher = socket.getCipher();
        const protocol = socket.getProtocol();
        
        socket.end();
        
        resolve({
          cipher,
          protocol,
          cert,
          cipherName: cipher.name,
          cipherVersion: cipher.version
        });
      });
      
      socket.on('error', reject);
    });
  }
  
  /**
   * 脆弱性の追加
   */
  addVulnerability(vulnerability) {
    this.results.push({
      ...vulnerability,
      timestamp: new Date().toISOString(),
      scanner: 'Shopify-MCP-VulnerabilityScanner'
    });
    
    scannerLogger.warn('Vulnerability detected:', vulnerability);
  }
  
  /**
   * レポートの生成
   */
  generateReport() {
    const duration = this.endTime - this.startTime;
    
    const report = {
      summary: {
        targetUrl: this.config.targetUrl,
        scanDate: new Date(this.startTime).toISOString(),
        duration: `${duration}ms`,
        totalVulnerabilities: this.results.length,
        criticalCount: this.results.filter(v => v.severity === 'critical').length,
        highCount: this.results.filter(v => v.severity === 'high').length,
        mediumCount: this.results.filter(v => v.severity === 'medium').length,
        lowCount: this.results.filter(v => v.severity === 'low').length
      },
      vulnerabilities: this.results,
      recommendations: this.generateRecommendations()
    };
    
    scannerLogger.info('Scan completed', report.summary);
    
    return report;
  }
  
  /**
   * 推奨事項の生成
   */
  generateRecommendations() {
    const recommendations = [];
    
    if (this.results.some(v => v.type.includes('injection'))) {
      recommendations.push({
        priority: 'high',
        category: 'Input Validation',
        recommendation: 'Implement comprehensive input validation and parameterized queries'
      });
    }
    
    if (this.results.some(v => v.category === 'Broken Authentication')) {
      recommendations.push({
        priority: 'high',
        category: 'Authentication',
        recommendation: 'Strengthen authentication mechanisms and implement MFA'
      });
    }
    
    if (this.results.some(v => v.type === 'missing_security_header')) {
      recommendations.push({
        priority: 'medium',
        category: 'Security Headers',
        recommendation: 'Implement all recommended security headers'
      });
    }
    
    if (this.results.some(v => v.category === 'Cross-Site Scripting')) {
      recommendations.push({
        priority: 'high',
        category: 'Output Encoding',
        recommendation: 'Implement proper output encoding for all user-supplied data'
      });
    }
    
    return recommendations;
  }
}

module.exports = VulnerabilityScanner;